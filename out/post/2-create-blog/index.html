<!DOCTYPE html><html><head><link rel="preload" href="/_next/1c356f4e-0d46-4922-b0ef-58e09ca5340e/page/post/index.js" as="script"/><link rel="preload" href="/_next/1c356f4e-0d46-4922-b0ef-58e09ca5340e/page/_error/index.js" as="script"/><link rel="preload" href="/_next/a43daebd5b193df7c6e81c8f9450eeb5/app.js" as="script"/><meta charset="utf-8" class="next-head"/><title class="next-head">This is the default title</title><meta charset="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css"/><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/tachyons/4.7.4/tachyons.min.css"/><style type="text/css" data-styled-components="eJdjbb iPjUpu bumjXC bNeVpp" data-styled-components-is-local="true">/* sc-component-id: Wrapper-s1cexcdw-0 */

.eJdjbb{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;min-height:100vh;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.eJdjbb main{-webkit-flex:1;-ms-flex:1;flex:1;}
/* sc-component-id: Nav__Wrapper-s1grhrjp-0 */

.iPjUpu{padding:15px;border-bottom:1px solid #ddd;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;background:#387EF5;}.iPjUpu a{padding:0 15px;color:#FFF;}
/* sc-component-id: Footer-m5gwr2-0 */

.bNeVpp{padding:15px;background:#F5F5F5;}
/* sc-component-id: post__Wrapper-s1viaa64-0 */

.bumjXC{padding:3rem;max-width:750px;margin:0 auto;}@media (max-width:750px){.bumjXC{width:100%;padding:1rem;}}.bumjXC h1{color:#222;font-weight:bold;font-size:1.75rem;line-height:35px;font-family:"PT Sans",sans-serif;text-transform:capitalize;margin:0;}.bumjXC p{line-height:28px;color:#666;font-family:"PT Sans",sans-serif;}
</style><style type="text/css" data-styled-components="" data-styled-components-is-local="false">/* sc-component-id: sc-global-1151470906 */
ul{margin:0;padding:0;}
</style></head><body><div class="root"><div><div id="__next"><div data-reactroot="" data-reactid="1" data-react-checksum="-616584643"><footer class="Wrapper-s1cexcdw-0 eJdjbb" data-reactid="2"><!-- react-empty: 3 --><header data-reactid="4"><nav class="Nav__Wrapper-s1grhrjp-0 iPjUpu" data-reactid="5"><a href="/" data-reactid="6">Home</a><!-- react-text: 7 --> |<!-- /react-text --><a href="/about" data-reactid="8">About</a><!-- react-text: 9 --> |<!-- /react-text --><a href="/contact" data-reactid="10">Contact</a></nav></header><main data-reactid="11"><div class="post__Wrapper-s1viaa64-0 bumjXC" data-reactid="12"><h1 data-reactid="13"></h1><p data-reactid="14"><p>创建一个单页Javascript应用程序是一件非常有挑战的事情, 幸运的是, 开源世界给我们提供了一些好用的工具来简化, 加速单页应用的开发.</p>
<p>Create React App 就是这样一种工具。</p>
<p>即使是这样, 创建单页应用有非常高的学习曲线. 仍然需要我们学习客户端路由, 页面布局, 等技术. 如果你还想要运行服务器端渲染(SSR: Server Side Rendering), 事情就变得更加困难了。因此我们需要一个简单的方案。</p>
<p>刚好前不久，next.js 出了 3.0 版本，其中一个主要的特性就是支持静态文件输出，特别适合拿来生成静态博客。</p>
<p>使用Next.js框架给我们提供了以下能力。</p>
<ul>
<li>服务器端渲染(默认)</li>
<li>自动代码切分, 加速页面加载</li>
<li>简单的客户端路由(基于页面)</li>
<li>基于Webpack的开发环境, 支持热模块替换(HMR: Hot Module Replacement)</li>
<li>可以使用Express 或其他Node.js服务器实现</li>
<li>使用Babel和Webpack配置定制</li>
</ul>
<p>关于<a href="https://github.com/zeit/next.js">Next.js文档</a>的一些基础内容</p>
<ul>
<li>所有的.js文件会自动处理和渲染，并形成路由。</li>
<li>服务器渲染索引根目录下的 ./pages 文件夹</li>
<li>静态文件放在./static/中对应路由的/static/   例如 img src="/static/my-image.png" </li>
<li>暴露<head>供组件里头设置，在<head>里头可以设置title等等</li>
<li>我们能在顶级组件中的getInitialProps({pathname,query,asPath,req,res,jsonPageRes})获取到相应信息。query在服务器上配置自定义路由时很有用</li>
<li>自定义路由 const app = require('next')({process.env.NODE_ENV !== 'production'}); app.render()里可将query自定义的obj传进来供getInitialProps传进来供其使用。</li>
<li>支持动态导入 Dynamic Import</li>
<li>自定义document，加载./pages的_document.js文件。用来改写 <html>，<body> 的默认行为</li>
<li>next.config.js可设置静态html导出 </li>
</ul>
<p>在<a href="https://github.com/timberio/next-go/">next-go项目</a>的基础上做了一些修改。</p>
<ul>
<li>去掉了next-router,用express的路由配置来代替</li>
<li>去掉了从服务端fetch data，构建纯静态blog</li>
<li>将fetch data 部分使用markdown 静态文件转html 来实现</li>
</ul>
<p>先看next.config.js的静态导出配置，下面代码是next.js文档提供的方法。</p>
<pre><code class="js language-js">// next.config.js
module.exports = {
  exportPathMap: function() {
    return {
      '/': { page: '/' },
      '/about': { page: '/about' },
      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },
      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },
      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } }
    }
  }
}
</code></pre>
<p>这就相当于写死了，当我每加一个页面（发一篇文章）我就得在这里配置一下路由，然而我并不想这么做。</p>
<pre><code class="js language-js">const readArticles = require("./lib/readArticles");

module.exports = {
    async exportPathMap() {
        const files = await readArticles();
        const pages = files.reduce(
            (pages, file) =&gt;
                Object.assign({}, pages, {
                    [file.link]: {
                        page: "/post",
                        query: { content: file.result }
                    }
                }),
            {}
        );

        return Object.assign({}, pages, {
            "/": {
                page: "/",
                query: {
                    articles: files.map(item =&gt; ({
                        link: item.link,
                        title: item.title
                    }))
                }
            }
        });
    }
};
</code></pre>
<p>于是就得动态生成路由，readArticles里头用到了fs，这里封装了一层，可以将本地的你想要的文件读出来得到数组，每一项就是处理后md生成的对象（包括title，date，content什么的），再通过query对象可以传到./pages/post.js，在组建中 <code>getInitialProps</code>方法里头接收，再通过showdown.Converter()将其转成html，使用dangerouslySetInnerHTML={{ __html: query.content }}成功转成页面。</p>
<p>接着看，我将next-go项目里的next-router去掉了，因为传参的原因，用它的router进行传参，他会将参数拼接到url后面。于是我用a标签替代路由跳转的动作，并且用express做了处理。</p>
<pre><code class="js language-js">const files = await readArticles();
const server = express();
const app = next();

server.get("/post/:name", (req, res) =&gt; {
    const file = files.find(item =&gt; item.link === req.path);
    return app.render(req, res, "/post", {
        content: file.result
    });
});
</code></pre>
<p>item.link 实际上是一个'post/hello-world' 类似的东西，这里将它转一下，实际上访问的是/post，同理在query传参。</p>
<p>blog基本搭起来了，但是懂得东西还是比较浅的。接下来还需学习更多做进一步的开发。</p>
<p>参考资料</p>
<ul>
<li><a href="https://github.com/zeit/next.js">Next.js的文档</a></li>
<li><a href="https://learnnextjs.com/basics/getting-started">https://learnnextjs.com/basics/getting-started</a></li>
<li><a href="https://github.com/timberio/next-go/">https://github.com/timberio/next-go/</a></li>
<li><a href="https://github.com/clinyong/blog">https://github.com/clinyong/blog</a></li>
</ul></p></div></main><footer class="Footer-m5gwr2-0 bNeVpp" data-reactid="15">Footer</footer></footer></div></div><div id="__next-error"></div></div></div><div><script>
          __NEXT_DATA__ = {"props":{"content":"\u003cp\u003e创建一个单页Javascript应用程序是一件非常有挑战的事情, 幸运的是, 开源世界给我们提供了一些好用的工具来简化, 加速单页应用的开发.\u003c/p\u003e\n\u003cp\u003eCreate React App 就是这样一种工具。\u003c/p\u003e\n\u003cp\u003e即使是这样, 创建单页应用有非常高的学习曲线. 仍然需要我们学习客户端路由, 页面布局, 等技术. 如果你还想要运行服务器端渲染(SSR: Server Side Rendering), 事情就变得更加困难了。因此我们需要一个简单的方案。\u003c/p\u003e\n\u003cp\u003e刚好前不久，next.js 出了 3.0 版本，其中一个主要的特性就是支持静态文件输出，特别适合拿来生成静态博客。\u003c/p\u003e\n\u003cp\u003e使用Next.js框架给我们提供了以下能力。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e服务器端渲染(默认)\u003c/li\u003e\n\u003cli\u003e自动代码切分, 加速页面加载\u003c/li\u003e\n\u003cli\u003e简单的客户端路由(基于页面)\u003c/li\u003e\n\u003cli\u003e基于Webpack的开发环境, 支持热模块替换(HMR: Hot Module Replacement)\u003c/li\u003e\n\u003cli\u003e可以使用Express 或其他Node.js服务器实现\u003c/li\u003e\n\u003cli\u003e使用Babel和Webpack配置定制\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e关于\u003ca href=\"https://github.com/zeit/next.js\"\u003eNext.js文档\u003c/a\u003e的一些基础内容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e所有的.js文件会自动处理和渲染，并形成路由。\u003c/li\u003e\n\u003cli\u003e服务器渲染索引根目录下的 ./pages 文件夹\u003c/li\u003e\n\u003cli\u003e静态文件放在./static/中对应路由的/static/   例如 img src=\"/static/my-image.png\" \u003c/li\u003e\n\u003cli\u003e暴露\u003chead\u003e供组件里头设置，在\u003chead\u003e里头可以设置title等等\u003c/li\u003e\n\u003cli\u003e我们能在顶级组件中的getInitialProps({pathname,query,asPath,req,res,jsonPageRes})获取到相应信息。query在服务器上配置自定义路由时很有用\u003c/li\u003e\n\u003cli\u003e自定义路由 const app = require('next')({process.env.NODE_ENV !== 'production'}); app.render()里可将query自定义的obj传进来供getInitialProps传进来供其使用。\u003c/li\u003e\n\u003cli\u003e支持动态导入 Dynamic Import\u003c/li\u003e\n\u003cli\u003e自定义document，加载./pages的_document.js文件。用来改写 \u003chtml\u003e，\u003cbody\u003e 的默认行为\u003c/li\u003e\n\u003cli\u003enext.config.js可设置静态html导出 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在\u003ca href=\"https://github.com/timberio/next-go/\"\u003enext-go项目\u003c/a\u003e的基础上做了一些修改。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e去掉了next-router,用express的路由配置来代替\u003c/li\u003e\n\u003cli\u003e去掉了从服务端fetch data，构建纯静态blog\u003c/li\u003e\n\u003cli\u003e将fetch data 部分使用markdown 静态文件转html 来实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e先看next.config.js的静态导出配置，下面代码是next.js文档提供的方法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"js language-js\"\u003e// next.config.js\nmodule.exports = {\n  exportPathMap: function() {\n    return {\n      '/': { page: '/' },\n      '/about': { page: '/about' },\n      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },\n      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },\n      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这就相当于写死了，当我每加一个页面（发一篇文章）我就得在这里配置一下路由，然而我并不想这么做。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"js language-js\"\u003econst readArticles = require(\"./lib/readArticles\");\n\nmodule.exports = {\n    async exportPathMap() {\n        const files = await readArticles();\n        const pages = files.reduce(\n            (pages, file) =\u0026gt;\n                Object.assign({}, pages, {\n                    [file.link]: {\n                        page: \"/post\",\n                        query: { content: file.result }\n                    }\n                }),\n            {}\n        );\n\n        return Object.assign({}, pages, {\n            \"/\": {\n                page: \"/\",\n                query: {\n                    articles: files.map(item =\u0026gt; ({\n                        link: item.link,\n                        title: item.title\n                    }))\n                }\n            }\n        });\n    }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e于是就得动态生成路由，readArticles里头用到了fs，这里封装了一层，可以将本地的你想要的文件读出来得到数组，每一项就是处理后md生成的对象（包括title，date，content什么的），再通过query对象可以传到./pages/post.js，在组建中 \u003ccode\u003egetInitialProps\u003c/code\u003e方法里头接收，再通过showdown.Converter()将其转成html，使用dangerouslySetInnerHTML={{ __html: query.content }}成功转成页面。\u003c/p\u003e\n\u003cp\u003e接着看，我将next-go项目里的next-router去掉了，因为传参的原因，用它的router进行传参，他会将参数拼接到url后面。于是我用a标签替代路由跳转的动作，并且用express做了处理。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"js language-js\"\u003econst files = await readArticles();\nconst server = express();\nconst app = next();\n\nserver.get(\"/post/:name\", (req, res) =\u0026gt; {\n    const file = files.find(item =\u0026gt; item.link === req.path);\n    return app.render(req, res, \"/post\", {\n        content: file.result\n    });\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eitem.link 实际上是一个'post/hello-world' 类似的东西，这里将它转一下，实际上访问的是/post，同理在query传参。\u003c/p\u003e\n\u003cp\u003eblog基本搭起来了，但是懂得东西还是比较浅的。接下来还需学习更多做进一步的开发。\u003c/p\u003e\n\u003cp\u003e参考资料\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/zeit/next.js\"\u003eNext.js的文档\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://learnnextjs.com/basics/getting-started\"\u003ehttps://learnnextjs.com/basics/getting-started\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/timberio/next-go/\"\u003ehttps://github.com/timberio/next-go/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/clinyong/blog\"\u003ehttps://github.com/clinyong/blog\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e"},"pathname":"/post","query":{"content":"\n创建一个单页Javascript应用程序是一件非常有挑战的事情, 幸运的是, 开源世界给我们提供了一些好用的工具来简化, 加速单页应用的开发.\n\nCreate React App 就是这样一种工具。\n\n即使是这样, 创建单页应用有非常高的学习曲线. 仍然需要我们学习客户端路由, 页面布局, 等技术. 如果你还想要运行服务器端渲染(SSR: Server Side Rendering), 事情就变得更加困难了。因此我们需要一个简单的方案。\n\n刚好前不久，next.js 出了 3.0 版本，其中一个主要的特性就是支持静态文件输出，特别适合拿来生成静态博客。\n\n使用Next.js框架给我们提供了以下能力。\n- 服务器端渲染(默认)\n- 自动代码切分, 加速页面加载\n- 简单的客户端路由(基于页面)\n- 基于Webpack的开发环境, 支持热模块替换(HMR: Hot Module Replacement)\n- 可以使用Express 或其他Node.js服务器实现\n- 使用Babel和Webpack配置定制\n\n关于[Next.js文档](https://github.com/zeit/next.js)的一些基础内容\n- 所有的.js文件会自动处理和渲染，并形成路由。\n- 服务器渲染索引根目录下的 ./pages 文件夹\n- 静态文件放在./static/中对应路由的/static/   例如 img src=\"/static/my-image.png\" \n- 暴露\u003chead\u003e供组件里头设置，在\u003chead\u003e里头可以设置title等等\n- 我们能在顶级组件中的getInitialProps({pathname,query,asPath,req,res,jsonPageRes})获取到相应信息。query在服务器上配置自定义路由时很有用\n- 自定义路由 const app = require('next')({process.env.NODE_ENV !== 'production'}); app.render()里可将query自定义的obj传进来供getInitialProps传进来供其使用。\n- 支持动态导入 Dynamic Import\n- 自定义document，加载./pages的_document.js文件。用来改写 \u003chtml\u003e，\u003cbody\u003e 的默认行为\n- next.config.js可设置静态html导出 \n\n在[next-go项目](https://github.com/timberio/next-go/)的基础上做了一些修改。\n- 去掉了next-router,用express的路由配置来代替\n- 去掉了从服务端fetch data，构建纯静态blog\n- 将fetch data 部分使用markdown 静态文件转html 来实现\n\n先看next.config.js的静态导出配置，下面代码是next.js文档提供的方法。\n```js\n// next.config.js\nmodule.exports = {\n  exportPathMap: function() {\n    return {\n      '/': { page: '/' },\n      '/about': { page: '/about' },\n      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },\n      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },\n      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } }\n    }\n  }\n}\n```\n这就相当于写死了，当我每加一个页面（发一篇文章）我就得在这里配置一下路由，然而我并不想这么做。\n\n```js\nconst readArticles = require(\"./lib/readArticles\");\n\nmodule.exports = {\n\tasync exportPathMap() {\n\t\tconst files = await readArticles();\n\t\tconst pages = files.reduce(\n\t\t\t(pages, file) =\u003e\n\t\t\t\tObject.assign({}, pages, {\n\t\t\t\t\t[file.link]: {\n\t\t\t\t\t\tpage: \"/post\",\n\t\t\t\t\t\tquery: { content: file.result }\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t{}\n\t\t);\n\n\t\treturn Object.assign({}, pages, {\n\t\t\t\"/\": {\n\t\t\t\tpage: \"/\",\n\t\t\t\tquery: {\n\t\t\t\t\tarticles: files.map(item =\u003e ({\n\t\t\t\t\t\tlink: item.link,\n\t\t\t\t\t\ttitle: item.title\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n};\n```\n于是就得动态生成路由，readArticles里头用到了fs，这里封装了一层，可以将本地的你想要的文件读出来得到数组，每一项就是处理后md生成的对象（包括title，date，content什么的），再通过query对象可以传到./pages/post.js，在组建中 `getInitialProps`方法里头接收，再通过showdown.Converter()将其转成html，使用dangerouslySetInnerHTML={{ __html: query.content }}成功转成页面。\n\n接着看，我将next-go项目里的next-router去掉了，因为传参的原因，用它的router进行传参，他会将参数拼接到url后面。于是我用a标签替代路由跳转的动作，并且用express做了处理。\n\n```js\nconst files = await readArticles();\nconst server = express();\nconst app = next();\n\nserver.get(\"/post/:name\", (req, res) =\u003e {\n    const file = files.find(item =\u003e item.link === req.path);\n    return app.render(req, res, \"/post\", {\n        content: file.result\n    });\n});\n```\n\nitem.link 实际上是一个'post/hello-world' 类似的东西，这里将它转一下，实际上访问的是/post，同理在query传参。\n\nblog基本搭起来了，但是懂得东西还是比较浅的。接下来还需学习更多做进一步的开发。\n\n\n\n参考资料\n- [Next.js的文档](https://github.com/zeit/next.js)\n- [https://learnnextjs.com/basics/getting-started](https://learnnextjs.com/basics/getting-started)\n- [https://github.com/timberio/next-go/](https://github.com/timberio/next-go/)\n- [https://github.com/clinyong/blog](https://github.com/clinyong/blog)\n\n"},"buildId":"1c356f4e-0d46-4922-b0ef-58e09ca5340e","buildStats":{"app.js":{"hash":"a43daebd5b193df7c6e81c8f9450eeb5"}},"assetPrefix":"","nextExport":true,"err":null,"chunks":[]}
          module={}
          __NEXT_LOADED_PAGES__ = []
          __NEXT_LOADED_CHUNKS__ = []

          __NEXT_REGISTER_PAGE = function (route, fn) {
            __NEXT_LOADED_PAGES__.push({ route: route, fn: fn })
          }

          __NEXT_REGISTER_CHUNK = function (chunkName, fn) {
            __NEXT_LOADED_CHUNKS__.push({ chunkName: chunkName, fn: fn })
          }
        </script><script async="" id="__NEXT_PAGE__/post" type="text/javascript" src="/_next/1c356f4e-0d46-4922-b0ef-58e09ca5340e/page/post/index.js"></script><script async="" id="__NEXT_PAGE__/_error" type="text/javascript" src="/_next/1c356f4e-0d46-4922-b0ef-58e09ca5340e/page/_error/index.js"></script><div></div><script type="text/javascript" src="/_next/a43daebd5b193df7c6e81c8f9450eeb5/app.js" async=""></script></div></body></html>