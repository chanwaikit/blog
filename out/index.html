<!DOCTYPE html><html style="height:100%;"><head><link rel="preload" href="/_next/f8931376-58e9-447b-8d52-1d9a1f6a480b/page/index.js" as="script"/><link rel="preload" href="/_next/f8931376-58e9-447b-8d52-1d9a1f6a480b/page/_error/index.js" as="script"/><link rel="preload" href="/_next/bae682bdf3379f7745976f059fd0e35e/app.js" as="script"/><meta charset="utf-8" class="next-head"/><title class="next-head">kit&#x27;s blog</title><meta charset="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><link rel="stylesheet" href="/static/markdown/github-gist.css"/><style type="text/css" data-styled-components="jJakbZ hrSbzT iGfeXH jTdOtx fMdkNR ecEToU gRBuCR NAapy fdYFTF kYoEaS hUBbUf fjNOrI" data-styled-components-is-local="true">/* sc-component-id: Wrapper-p7ykbh-0 */

.hrSbzT{height:100%;width:100%;}
/* sc-component-id: Nav__Wrapper-s1ad7n4l-0 */

.jJakbZ{padding:40px 50px;font-size:14px;border-bottom:1px solid #EEE;}.jJakbZ span{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:14px;}.jJakbZ a{margin-right:10px;color:#000;-webkit-text-decoration:none;text-decoration:none;padding-right:10px;font-weight:600;}
/* sc-component-id: Footer-s145rwsn-0 */

.fjNOrI{height:80px;-webkit-text-align:center;text-align:center;font-size:11px;border-top:1px solid #EEE;width:99%;text-align:center;}
/* sc-component-id: Post__Wrapper-s1jwipc6-0 */

.ecEToU a{text-decoration:none;display:block;margin:0 10px 8px 0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";color:#444;-webkit-text-decoration:none;text-decoration:none;font-size:14px;}.ecEToU a:visited{color:#444;text-decoration:underline;}.ecEToU p{font-size:1.2rem;line-height:35px;color:#444;font-family:"PT Serif",sans-serif;margin:0;}
/* sc-component-id: Post__WrapperDiv-s1jwipc6-1 */

.gRBuCR{margin:0 10px 8px 0;}
/* sc-component-id: Main__Container-s1kq5vfa-0 */

.iGfeXH{margin:30px 0 0 0;width:100%;}
/* sc-component-id: Main__Menu-s1kq5vfa-1 */

.jTdOtx{width:25%;display:inline-block;vertical-align:top;}.jTdOtx h3{padding:0;margin:0 0 15px 0;font-size:18px;font-weight:600;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";}
/* sc-component-id: Main__MenuBody-s1kq5vfa-2 */

.fMdkNR{padding:0 0 0 50px;}.fMdkNR h3{padding:0;margin:0 0 15px 0;font-size:18px;font-weight:600;}
/* sc-component-id: Main__Content-s1kq5vfa-3 */

.NAapy{width:75%;display:inline-block;vertical-align:top;margin:0 0 50px 0;}
/* sc-component-id: Main__ContentBody-s1kq5vfa-4 */

.fdYFTF{border-left:1px solid #DDD;padding-left:20px;}
/* sc-component-id: post__Wrapper-k7wrto-0 */

.kYoEaS{display:inline-block;vertical-align:top;width:75%;margin:0 0 50px 0;}.kYoEaS h2{margin:0 0 20px 0;padding:0;font-size:25px;color:#333;}
/* sc-component-id: post__Content-k7wrto-1 */

.hUBbUf{background-color:#fff;font-size:15px;color:#333;}@media screen and (min-width:770px){.hUBbUf{min-height:500px;}.hUBbUf a:hover{text-decoration:underline;cursor:pointer;}}.hUBbUf a{color:#0366d6;text-decoration:none;}.hUBbUf ul{padding-left:2em;}.hUBbUf p,.hUBbUf li{line-height:1.8;}.hUBbUf img{display:block;max-width:100%;margin:0 auto 30px;}@media screen and (min-width:770px){.hUBbUf img{max-width:500px;}}.hUBbUf code{background:#f6f8fa;padding:2px 5px;}.hUBbUf pre{font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;background:#f6f8fa;padding:20px;overflow-x:auto;line-height:1.8;}.hUBbUf pre > code{padding:0;}
</style><style type="text/css" data-styled-components="" data-styled-components-is-local="false">/* sc-component-id: sc-global-2284531576 */
ul{margin:0;padding:0;}
</style><style type="text/css" data-styled-components="eTWDje xVRaC" data-styled-components-is-local="true">/* sc-component-id: pages__Wrapper-s97rp0i-0 */

.eTWDje{display:inline-block;vertical-align:top;width:75%;margin:0 0 50px 0;}.eTWDje h2{margin:0 0 20px 0;padding:0;font-size:25px;color:#333;}
/* sc-component-id: pages__Content-s97rp0i-1 */

.xVRaC{background-color:#fff;font-size:15px;color:#333;}@media screen and (min-width:770px){.xVRaC{min-height:500px;}.xVRaC a:hover{text-decoration:underline;cursor:pointer;}}.xVRaC a{color:#0366d6;text-decoration:none;}.xVRaC ul{padding-left:2em;}.xVRaC p,.xVRaC li{line-height:1.8;}.xVRaC img{display:block;max-width:100%;margin:0 auto 30px;}@media screen and (min-width:770px){.xVRaC img{max-width:500px;}}.xVRaC code{background:#f6f8fa;padding:2px 5px;}.xVRaC pre{font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;background:#f6f8fa;padding:20px;overflow-x:auto;line-height:1.8;}.xVRaC pre > code{padding:0;}
</style></head><body style="display:flex;flex-direction:column;height:100%;margin:0px;"><div class="root" style="flex:1;"><div><div id="__next"><div data-reactroot="" data-reactid="1" data-react-checksum="201487922"><div data-reactid="2"><!-- react-empty: 3 --><header style="flex:0 0 auto;" data-reactid="4"><div class="Nav__Wrapper-s1ad7n4l-0 jJakbZ" data-reactid="5"><span data-reactid="6"><a href="/" data-reactid="7">Home</a></span><span data-reactid="8"><a href="/about" data-reactid="9">About</a></span><span data-reactid="10"><a href="/contact" data-reactid="11">Contact</a></span></div></header><footer class="Wrapper-p7ykbh-0 hrSbzT" data-reactid="12"><main data-reactid="13"><div class="Main__Container-s1kq5vfa-0 iGfeXH" data-reactid="14"><div class="Main__Menu-s1kq5vfa-1 jTdOtx" data-reactid="15"><div class="Main__MenuBody-s1kq5vfa-2 fMdkNR" data-reactid="16"><h3 data-reactid="17">Basics</h3><ul data-reactid="18"><div class="Post__Wrapper-s1jwipc6-0 ecEToU" data-reactid="19"><div class="Post__WrapperDiv-s1jwipc6-1 gRBuCR" data-reactid="20"><a href="/post/2-create-blog" data-reactid="21"><!-- react-text: 22 -->2017.09.14<!-- /react-text --><!-- react-text: 23 --> - <!-- /react-text --><!-- react-text: 24 -->用next.js搭建blog<!-- /react-text --></a></div></div><div class="Post__Wrapper-s1jwipc6-0 ecEToU" data-reactid="25"><div class="Post__WrapperDiv-s1jwipc6-1 gRBuCR" data-reactid="26"><a href="/post/1-hello-world" data-reactid="27"><!-- react-text: 28 -->2017.09.11<!-- /react-text --><!-- react-text: 29 --> - <!-- /react-text --><!-- react-text: 30 -->Hello World!<!-- /react-text --></a></div></div></ul></div></div><div class="Main__Content-s1kq5vfa-3 NAapy" data-reactid="31"><div class="Main__ContentBody-s1kq5vfa-4 fdYFTF" data-reactid="32"><div class="pages__Wrapper-s97rp0i-0 eTWDje" data-reactid="33"><h2 data-reactid="34">用next.js搭建blog</h2><div class="pages__Content-s97rp0i-1 xVRaC" data-reactid="35"><p>创建一个单页Javascript应用程序是一件非常有挑战的事情, 幸运的是, 开源世界给我们提供了一些好用的工具来简化, 加速单页应用的开发.</p>
<p>Create React App 就是这样一种工具。</p>
<p>即使是这样, 创建单页应用有非常高的学习曲线. 仍然需要我们学习客户端路由, 页面布局, 等技术. 如果你还想要运行服务器端渲染(SSR: Server Side Rendering), 事情就变得更加困难了。因此我们需要一个简单的方案。</p>
<p>刚好前不久，next.js 出了 3.0 版本，其中一个主要的特性就是支持静态文件输出，特别适合拿来生成静态博客。</p>
<p>使用Next.js框架给我们提供了以下能力。</p>
<ul>
<li>服务器端渲染(默认)</li>
<li>自动代码切分, 加速页面加载</li>
<li>简单的客户端路由(基于页面)</li>
<li>基于Webpack的开发环境, 支持热模块替换(HMR: Hot Module Replacement)</li>
<li>可以使用Express 或其他Node.js服务器实现</li>
<li>使用Babel和Webpack配置定制</li>
</ul>
<p>关于<a href="https://github.com/zeit/next.js">Next.js文档</a>的一些基础内容</p>
<ul>
<li>所有的.js文件会自动处理和渲染，并形成路由。</li>
<li>服务器渲染索引根目录下的 ./pages 文件夹</li>
<li>静态文件放在./static/中对应路由的/static/   例如 img src="/static/my-image.png" </li>
<li>暴露<head>供组件里头设置，在<head>里头可以设置title等等</li>
<li>我们能在顶级组件中的getInitialProps({pathname,query,asPath,req,res,jsonPageRes})获取到相应信息。query在服务器上配置自定义路由时很有用</li>
<li>自定义路由 const app = require('next')({process.env.NODE_ENV !== 'production'}); app.render()里可将query自定义的obj传进来供getInitialProps传进来供其使用。</li>
<li>支持动态导入 Dynamic Import</li>
<li>自定义document，加载./pages的_document.js文件。用来改写 <html>，<body> 的默认行为</li>
<li>next.config.js可设置静态html导出 </li>
</ul>
<p>在<a href="https://github.com/timberio/next-go/">next-go项目</a>的基础上做了一些修改。</p>
<ul>
<li>去掉了next-router,用express的路由配置来代替</li>
<li>去掉了从服务端fetch data，构建纯静态blog</li>
<li>将fetch data 部分使用markdown 静态文件转html 来实现</li>
</ul>
<p>先看next.config.js的静态导出配置，下面代码是next.js文档提供的方法。</p>
<pre><code class="js language-js">// next.config.js
module.exports = {
  exportPathMap: function() {
    return {
      '/': { page: '/' },
      '/about': { page: '/about' },
      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },
      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },
      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } }
    }
  }
}
</code></pre>
<p>这就相当于写死了，当我每加一个页面（发一篇文章）我就得在这里配置一下路由，然而我并不想这么做。</p>
<pre><code class="js language-js">const readArticles = require("./lib/readArticles");

module.exports = {
    async exportPathMap() {
        const files = await readArticles();
        const pages = files.reduce(
            (pages, file) =&gt;
                Object.assign({}, pages, {
                    [file.link]: {
                        page: "/post",
                        query: { content: file.result }
                    }
                }),
            {}
        );

        return Object.assign({}, pages, {
            "/": {
                page: "/",
                query: {
                    articles: files.map(item =&gt; ({
                        link: item.link,
                        title: item.title
                    }))
                }
            }
        });
    }
};
</code></pre>
<p>于是就得动态生成路由，readArticles里头用到了fs，这里封装了一层，可以将本地的你想要的文件读出来得到数组，每一项就是处理后md生成的对象（包括title，date，content什么的），再通过query对象可以传到./pages/post.js，在组件中 <code>getInitialProps</code>方法里头接收，再通过showdown.Converter()将其转成html，使用dangerouslySetInnerHTML={{ __html: query.content }}成功转成页面。</p>
<p>接着看，我将next-go项目里的next-router去掉了，因为传参的原因，用它的router进行传参，他会将参数拼接到url后面。于是我用a标签替代路由跳转的动作，并且用express做了处理。</p>
<pre><code class="js language-js">const files = await readArticles();
const server = express();
const app = next();

server.get("/post/:name", (req, res) =&gt; {
    const file = files.find(item =&gt; item.link === req.path);
    return app.render(req, res, "/post", {
        content: file.result
    });
});
</code></pre>
<p>item.link 实际上是一个'post/hello-world' 类似的东西，这里将它转一下，实际上访问的是/post，同理在query传参。</p>
<p>blog基本搭起来了，但是懂得东西还是比较浅的。接下来还需学习更多做进一步的开发。</p>
<p>参考资料</p>
<ul>
<li><a href="https://github.com/zeit/next.js">Next.js的文档</a></li>
<li><a href="https://learnnextjs.com/basics/getting-started">https://learnnextjs.com/basics/getting-started</a></li>
<li><a href="https://github.com/timberio/next-go/">https://github.com/timberio/next-go/</a></li>
<li><a href="https://github.com/clinyong/blog">https://github.com/clinyong/blog</a></li>
</ul></div></div></div></div></div></main></footer></div></div></div><div id="__next-error"></div></div></div><footer class="Footer-s145rwsn-0 fjNOrI" style="flex:0 0 auto;"><div>Brought to you by <a href="https://github.com/chanwaikit" target="_blank">chanwaikit</a></div><div><a href="http://chanwaikit.coding.me">here</a></div></footer><div><script>
          __NEXT_DATA__ = {"props":{"articles":[{"link":"/post/2-create-blog","title":"用next.js搭建blog","date":"2017.09.14","result":{"meta":{"title":"用next.js搭建blog","date":"2017.09.14"},"content":"\n创建一个单页Javascript应用程序是一件非常有挑战的事情, 幸运的是, 开源世界给我们提供了一些好用的工具来简化, 加速单页应用的开发.\n\nCreate React App 就是这样一种工具。\n\n即使是这样, 创建单页应用有非常高的学习曲线. 仍然需要我们学习客户端路由, 页面布局, 等技术. 如果你还想要运行服务器端渲染(SSR: Server Side Rendering), 事情就变得更加困难了。因此我们需要一个简单的方案。\n\n刚好前不久，next.js 出了 3.0 版本，其中一个主要的特性就是支持静态文件输出，特别适合拿来生成静态博客。\n\n使用Next.js框架给我们提供了以下能力。\n- 服务器端渲染(默认)\n- 自动代码切分, 加速页面加载\n- 简单的客户端路由(基于页面)\n- 基于Webpack的开发环境, 支持热模块替换(HMR: Hot Module Replacement)\n- 可以使用Express 或其他Node.js服务器实现\n- 使用Babel和Webpack配置定制\n\n关于[Next.js文档](https://github.com/zeit/next.js)的一些基础内容\n- 所有的.js文件会自动处理和渲染，并形成路由。\n- 服务器渲染索引根目录下的 ./pages 文件夹\n- 静态文件放在./static/中对应路由的/static/   例如 img src=\"/static/my-image.png\" \n- 暴露\u003chead\u003e供组件里头设置，在\u003chead\u003e里头可以设置title等等\n- 我们能在顶级组件中的getInitialProps({pathname,query,asPath,req,res,jsonPageRes})获取到相应信息。query在服务器上配置自定义路由时很有用\n- 自定义路由 const app = require('next')({process.env.NODE_ENV !== 'production'}); app.render()里可将query自定义的obj传进来供getInitialProps传进来供其使用。\n- 支持动态导入 Dynamic Import\n- 自定义document，加载./pages的_document.js文件。用来改写 \u003chtml\u003e，\u003cbody\u003e 的默认行为\n- next.config.js可设置静态html导出 \n\n在[next-go项目](https://github.com/timberio/next-go/)的基础上做了一些修改。\n- 去掉了next-router,用express的路由配置来代替\n- 去掉了从服务端fetch data，构建纯静态blog\n- 将fetch data 部分使用markdown 静态文件转html 来实现\n\n先看next.config.js的静态导出配置，下面代码是next.js文档提供的方法。\n```js\n// next.config.js\nmodule.exports = {\n  exportPathMap: function() {\n    return {\n      '/': { page: '/' },\n      '/about': { page: '/about' },\n      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },\n      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },\n      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } }\n    }\n  }\n}\n```\n这就相当于写死了，当我每加一个页面（发一篇文章）我就得在这里配置一下路由，然而我并不想这么做。\n\n```js\nconst readArticles = require(\"./lib/readArticles\");\n\nmodule.exports = {\n\tasync exportPathMap() {\n\t\tconst files = await readArticles();\n\t\tconst pages = files.reduce(\n\t\t\t(pages, file) =\u003e\n\t\t\t\tObject.assign({}, pages, {\n\t\t\t\t\t[file.link]: {\n\t\t\t\t\t\tpage: \"/post\",\n\t\t\t\t\t\tquery: { content: file.result }\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t{}\n\t\t);\n\n\t\treturn Object.assign({}, pages, {\n\t\t\t\"/\": {\n\t\t\t\tpage: \"/\",\n\t\t\t\tquery: {\n\t\t\t\t\tarticles: files.map(item =\u003e ({\n\t\t\t\t\t\tlink: item.link,\n\t\t\t\t\t\ttitle: item.title\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n};\n```\n于是就得动态生成路由，readArticles里头用到了fs，这里封装了一层，可以将本地的你想要的文件读出来得到数组，每一项就是处理后md生成的对象（包括title，date，content什么的），再通过query对象可以传到./pages/post.js，在组件中 `getInitialProps`方法里头接收，再通过showdown.Converter()将其转成html，使用dangerouslySetInnerHTML={{ __html: query.content }}成功转成页面。\n\n接着看，我将next-go项目里的next-router去掉了，因为传参的原因，用它的router进行传参，他会将参数拼接到url后面。于是我用a标签替代路由跳转的动作，并且用express做了处理。\n\n```js\nconst files = await readArticles();\nconst server = express();\nconst app = next();\n\nserver.get(\"/post/:name\", (req, res) =\u003e {\n    const file = files.find(item =\u003e item.link === req.path);\n    return app.render(req, res, \"/post\", {\n        content: file.result\n    });\n});\n```\n\nitem.link 实际上是一个'post/hello-world' 类似的东西，这里将它转一下，实际上访问的是/post，同理在query传参。\n\nblog基本搭起来了，但是懂得东西还是比较浅的。接下来还需学习更多做进一步的开发。\n\n\n\n参考资料\n- [Next.js的文档](https://github.com/zeit/next.js)\n- [https://learnnextjs.com/basics/getting-started](https://learnnextjs.com/basics/getting-started)\n- [https://github.com/timberio/next-go/](https://github.com/timberio/next-go/)\n- [https://github.com/clinyong/blog](https://github.com/clinyong/blog)\n\n"},"fileName":"2-create-blog"},{"link":"/post/1-hello-world","title":"Hello World!","date":"2017.09.11","result":{"meta":{"title":"Hello World!","date":"2017.09.11"},"content":"\r\n最近心血来潮，看到了几个师傅和同学的github，感觉人与人之间的差距怎么那么大呢。也该发奋图强了，于是打算先迈出第一步，弄个blog。\r\n\r\n刚开始用了jekll来搭建，照着网上的教程走，搭出来后，心里很纠结，在想能不能用react来搭一个呢，毕竟现在工作中用的就是react。\r\n\r\n于是参照了官方文档和社区已有的项目，这个blog算是出来了。\r\n\r\nHello World~~\r\n\r\n"},"fileName":"1-hello-world"}],"content":"\u003cp\u003e创建一个单页Javascript应用程序是一件非常有挑战的事情, 幸运的是, 开源世界给我们提供了一些好用的工具来简化, 加速单页应用的开发.\u003c/p\u003e\n\u003cp\u003eCreate React App 就是这样一种工具。\u003c/p\u003e\n\u003cp\u003e即使是这样, 创建单页应用有非常高的学习曲线. 仍然需要我们学习客户端路由, 页面布局, 等技术. 如果你还想要运行服务器端渲染(SSR: Server Side Rendering), 事情就变得更加困难了。因此我们需要一个简单的方案。\u003c/p\u003e\n\u003cp\u003e刚好前不久，next.js 出了 3.0 版本，其中一个主要的特性就是支持静态文件输出，特别适合拿来生成静态博客。\u003c/p\u003e\n\u003cp\u003e使用Next.js框架给我们提供了以下能力。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e服务器端渲染(默认)\u003c/li\u003e\n\u003cli\u003e自动代码切分, 加速页面加载\u003c/li\u003e\n\u003cli\u003e简单的客户端路由(基于页面)\u003c/li\u003e\n\u003cli\u003e基于Webpack的开发环境, 支持热模块替换(HMR: Hot Module Replacement)\u003c/li\u003e\n\u003cli\u003e可以使用Express 或其他Node.js服务器实现\u003c/li\u003e\n\u003cli\u003e使用Babel和Webpack配置定制\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e关于\u003ca href=\"https://github.com/zeit/next.js\"\u003eNext.js文档\u003c/a\u003e的一些基础内容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e所有的.js文件会自动处理和渲染，并形成路由。\u003c/li\u003e\n\u003cli\u003e服务器渲染索引根目录下的 ./pages 文件夹\u003c/li\u003e\n\u003cli\u003e静态文件放在./static/中对应路由的/static/   例如 img src=\"/static/my-image.png\" \u003c/li\u003e\n\u003cli\u003e暴露\u003chead\u003e供组件里头设置，在\u003chead\u003e里头可以设置title等等\u003c/li\u003e\n\u003cli\u003e我们能在顶级组件中的getInitialProps({pathname,query,asPath,req,res,jsonPageRes})获取到相应信息。query在服务器上配置自定义路由时很有用\u003c/li\u003e\n\u003cli\u003e自定义路由 const app = require('next')({process.env.NODE_ENV !== 'production'}); app.render()里可将query自定义的obj传进来供getInitialProps传进来供其使用。\u003c/li\u003e\n\u003cli\u003e支持动态导入 Dynamic Import\u003c/li\u003e\n\u003cli\u003e自定义document，加载./pages的_document.js文件。用来改写 \u003chtml\u003e，\u003cbody\u003e 的默认行为\u003c/li\u003e\n\u003cli\u003enext.config.js可设置静态html导出 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在\u003ca href=\"https://github.com/timberio/next-go/\"\u003enext-go项目\u003c/a\u003e的基础上做了一些修改。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e去掉了next-router,用express的路由配置来代替\u003c/li\u003e\n\u003cli\u003e去掉了从服务端fetch data，构建纯静态blog\u003c/li\u003e\n\u003cli\u003e将fetch data 部分使用markdown 静态文件转html 来实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e先看next.config.js的静态导出配置，下面代码是next.js文档提供的方法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"js language-js\"\u003e// next.config.js\nmodule.exports = {\n  exportPathMap: function() {\n    return {\n      '/': { page: '/' },\n      '/about': { page: '/about' },\n      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },\n      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },\n      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这就相当于写死了，当我每加一个页面（发一篇文章）我就得在这里配置一下路由，然而我并不想这么做。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"js language-js\"\u003econst readArticles = require(\"./lib/readArticles\");\n\nmodule.exports = {\n    async exportPathMap() {\n        const files = await readArticles();\n        const pages = files.reduce(\n            (pages, file) =\u0026gt;\n                Object.assign({}, pages, {\n                    [file.link]: {\n                        page: \"/post\",\n                        query: { content: file.result }\n                    }\n                }),\n            {}\n        );\n\n        return Object.assign({}, pages, {\n            \"/\": {\n                page: \"/\",\n                query: {\n                    articles: files.map(item =\u0026gt; ({\n                        link: item.link,\n                        title: item.title\n                    }))\n                }\n            }\n        });\n    }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e于是就得动态生成路由，readArticles里头用到了fs，这里封装了一层，可以将本地的你想要的文件读出来得到数组，每一项就是处理后md生成的对象（包括title，date，content什么的），再通过query对象可以传到./pages/post.js，在组件中 \u003ccode\u003egetInitialProps\u003c/code\u003e方法里头接收，再通过showdown.Converter()将其转成html，使用dangerouslySetInnerHTML={{ __html: query.content }}成功转成页面。\u003c/p\u003e\n\u003cp\u003e接着看，我将next-go项目里的next-router去掉了，因为传参的原因，用它的router进行传参，他会将参数拼接到url后面。于是我用a标签替代路由跳转的动作，并且用express做了处理。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"js language-js\"\u003econst files = await readArticles();\nconst server = express();\nconst app = next();\n\nserver.get(\"/post/:name\", (req, res) =\u0026gt; {\n    const file = files.find(item =\u0026gt; item.link === req.path);\n    return app.render(req, res, \"/post\", {\n        content: file.result\n    });\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eitem.link 实际上是一个'post/hello-world' 类似的东西，这里将它转一下，实际上访问的是/post，同理在query传参。\u003c/p\u003e\n\u003cp\u003eblog基本搭起来了，但是懂得东西还是比较浅的。接下来还需学习更多做进一步的开发。\u003c/p\u003e\n\u003cp\u003e参考资料\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/zeit/next.js\"\u003eNext.js的文档\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://learnnextjs.com/basics/getting-started\"\u003ehttps://learnnextjs.com/basics/getting-started\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/timberio/next-go/\"\u003ehttps://github.com/timberio/next-go/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/clinyong/blog\"\u003ehttps://github.com/clinyong/blog\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"用next.js搭建blog"},"pathname":"/","query":{"articles":[{"link":"/post/2-create-blog","title":"用next.js搭建blog","date":"2017.09.14","result":{"meta":{"title":"用next.js搭建blog","date":"2017.09.14"},"content":"\n创建一个单页Javascript应用程序是一件非常有挑战的事情, 幸运的是, 开源世界给我们提供了一些好用的工具来简化, 加速单页应用的开发.\n\nCreate React App 就是这样一种工具。\n\n即使是这样, 创建单页应用有非常高的学习曲线. 仍然需要我们学习客户端路由, 页面布局, 等技术. 如果你还想要运行服务器端渲染(SSR: Server Side Rendering), 事情就变得更加困难了。因此我们需要一个简单的方案。\n\n刚好前不久，next.js 出了 3.0 版本，其中一个主要的特性就是支持静态文件输出，特别适合拿来生成静态博客。\n\n使用Next.js框架给我们提供了以下能力。\n- 服务器端渲染(默认)\n- 自动代码切分, 加速页面加载\n- 简单的客户端路由(基于页面)\n- 基于Webpack的开发环境, 支持热模块替换(HMR: Hot Module Replacement)\n- 可以使用Express 或其他Node.js服务器实现\n- 使用Babel和Webpack配置定制\n\n关于[Next.js文档](https://github.com/zeit/next.js)的一些基础内容\n- 所有的.js文件会自动处理和渲染，并形成路由。\n- 服务器渲染索引根目录下的 ./pages 文件夹\n- 静态文件放在./static/中对应路由的/static/   例如 img src=\"/static/my-image.png\" \n- 暴露\u003chead\u003e供组件里头设置，在\u003chead\u003e里头可以设置title等等\n- 我们能在顶级组件中的getInitialProps({pathname,query,asPath,req,res,jsonPageRes})获取到相应信息。query在服务器上配置自定义路由时很有用\n- 自定义路由 const app = require('next')({process.env.NODE_ENV !== 'production'}); app.render()里可将query自定义的obj传进来供getInitialProps传进来供其使用。\n- 支持动态导入 Dynamic Import\n- 自定义document，加载./pages的_document.js文件。用来改写 \u003chtml\u003e，\u003cbody\u003e 的默认行为\n- next.config.js可设置静态html导出 \n\n在[next-go项目](https://github.com/timberio/next-go/)的基础上做了一些修改。\n- 去掉了next-router,用express的路由配置来代替\n- 去掉了从服务端fetch data，构建纯静态blog\n- 将fetch data 部分使用markdown 静态文件转html 来实现\n\n先看next.config.js的静态导出配置，下面代码是next.js文档提供的方法。\n```js\n// next.config.js\nmodule.exports = {\n  exportPathMap: function() {\n    return {\n      '/': { page: '/' },\n      '/about': { page: '/about' },\n      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },\n      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },\n      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } }\n    }\n  }\n}\n```\n这就相当于写死了，当我每加一个页面（发一篇文章）我就得在这里配置一下路由，然而我并不想这么做。\n\n```js\nconst readArticles = require(\"./lib/readArticles\");\n\nmodule.exports = {\n\tasync exportPathMap() {\n\t\tconst files = await readArticles();\n\t\tconst pages = files.reduce(\n\t\t\t(pages, file) =\u003e\n\t\t\t\tObject.assign({}, pages, {\n\t\t\t\t\t[file.link]: {\n\t\t\t\t\t\tpage: \"/post\",\n\t\t\t\t\t\tquery: { content: file.result }\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t{}\n\t\t);\n\n\t\treturn Object.assign({}, pages, {\n\t\t\t\"/\": {\n\t\t\t\tpage: \"/\",\n\t\t\t\tquery: {\n\t\t\t\t\tarticles: files.map(item =\u003e ({\n\t\t\t\t\t\tlink: item.link,\n\t\t\t\t\t\ttitle: item.title\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n};\n```\n于是就得动态生成路由，readArticles里头用到了fs，这里封装了一层，可以将本地的你想要的文件读出来得到数组，每一项就是处理后md生成的对象（包括title，date，content什么的），再通过query对象可以传到./pages/post.js，在组件中 `getInitialProps`方法里头接收，再通过showdown.Converter()将其转成html，使用dangerouslySetInnerHTML={{ __html: query.content }}成功转成页面。\n\n接着看，我将next-go项目里的next-router去掉了，因为传参的原因，用它的router进行传参，他会将参数拼接到url后面。于是我用a标签替代路由跳转的动作，并且用express做了处理。\n\n```js\nconst files = await readArticles();\nconst server = express();\nconst app = next();\n\nserver.get(\"/post/:name\", (req, res) =\u003e {\n    const file = files.find(item =\u003e item.link === req.path);\n    return app.render(req, res, \"/post\", {\n        content: file.result\n    });\n});\n```\n\nitem.link 实际上是一个'post/hello-world' 类似的东西，这里将它转一下，实际上访问的是/post，同理在query传参。\n\nblog基本搭起来了，但是懂得东西还是比较浅的。接下来还需学习更多做进一步的开发。\n\n\n\n参考资料\n- [Next.js的文档](https://github.com/zeit/next.js)\n- [https://learnnextjs.com/basics/getting-started](https://learnnextjs.com/basics/getting-started)\n- [https://github.com/timberio/next-go/](https://github.com/timberio/next-go/)\n- [https://github.com/clinyong/blog](https://github.com/clinyong/blog)\n\n"},"fileName":"2-create-blog"},{"link":"/post/1-hello-world","title":"Hello World!","date":"2017.09.11","result":{"meta":{"title":"Hello World!","date":"2017.09.11"},"content":"\r\n最近心血来潮，看到了几个师傅和同学的github，感觉人与人之间的差距怎么那么大呢。也该发奋图强了，于是打算先迈出第一步，弄个blog。\r\n\r\n刚开始用了jekll来搭建，照着网上的教程走，搭出来后，心里很纠结，在想能不能用react来搭一个呢，毕竟现在工作中用的就是react。\r\n\r\n于是参照了官方文档和社区已有的项目，这个blog算是出来了。\r\n\r\nHello World~~\r\n\r\n"},"fileName":"1-hello-world"}]},"buildId":"f8931376-58e9-447b-8d52-1d9a1f6a480b","buildStats":{"app.js":{"hash":"bae682bdf3379f7745976f059fd0e35e"}},"assetPrefix":"","nextExport":true,"err":null,"chunks":[]}
          module={}
          __NEXT_LOADED_PAGES__ = []
          __NEXT_LOADED_CHUNKS__ = []

          __NEXT_REGISTER_PAGE = function (route, fn) {
            __NEXT_LOADED_PAGES__.push({ route: route, fn: fn })
          }

          __NEXT_REGISTER_CHUNK = function (chunkName, fn) {
            __NEXT_LOADED_CHUNKS__.push({ chunkName: chunkName, fn: fn })
          }
        </script><script async="" id="__NEXT_PAGE__/" type="text/javascript" src="/_next/f8931376-58e9-447b-8d52-1d9a1f6a480b/page/index.js"></script><script async="" id="__NEXT_PAGE__/_error" type="text/javascript" src="/_next/f8931376-58e9-447b-8d52-1d9a1f6a480b/page/_error/index.js"></script><div></div><script type="text/javascript" src="/_next/bae682bdf3379f7745976f059fd0e35e/app.js" async=""></script></div><script src="/static/markdown/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>